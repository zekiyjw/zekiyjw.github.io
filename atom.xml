<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张嘉桢の博客</title>
  
  
  <link href="https://zekiyjw.github.io/atom.xml" rel="self"/>
  
  <link href="https://zekiyjw.github.io/"/>
  <updated>2022-09-02T07:54:39.000Z</updated>
  <id>https://zekiyjw.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型</title>
    <link href="https://zekiyjw.github.io/2022/09/02/%E5%8E%9F%E5%9E%8B/"/>
    <id>https://zekiyjw.github.io/2022/09/02/%E5%8E%9F%E5%9E%8B/</id>
    <published>2022-09-02T07:54:39.000Z</published>
    <updated>2022-09-02T07:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="prototype"><a class="markdownIt-Anchor" href="#prototype"></a> Prototype</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var anotherObject = &#123;</span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个关联到 anotherObject 的对象</span></span><br><span class="line">var myObject = Object.create( anotherObject );</span><br><span class="line"></span><br><span class="line">myObject.a  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>对于默认的 <code>[[Get]]</code> 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 <code>[[Prototype]]</code> 链:</p><p><strong><code>Object.create()</code>它会创建一个对象并且把这个对象的 <code>[[Prototype]]</code> 关联到指定的对象 </strong></p><p>显然 <code>myObject.a</code> 并不存在，但是尽管如此，属性访问依然成功地（在 <code>anotherObject</code> 中）找到了值 <code>2</code>。</p><p>但是如果 <code>anotherObject</code> 中也找不到 <code>a</code> 并且 <code>[[Prototype]]</code> 链不为空的话，就会继续查找下去。</p><p>这个过程会持续到找到匹配的属性名或者查找完整条 <code>[[Prototype]]</code> 链。如果是后者的话， <code>[[Get]]</code> 操作的返回值是 <code>undefined</code>。</p><h2 id="objectprototype"><a class="markdownIt-Anchor" href="#objectprototype"></a> Object.Prototype</h2><p>所有普通的 <code>[[Prototype]]</code> 链最终都会指向内置的 <code>Object.prototype</code>。 由于所有的 “ 普通 ” （内置，不是特定主机的扩展）对象都 “ 源于 ” （或者说把 <code>[[Prototype]]</code> 链的顶端设置为）这个 <code>Object.prototype</code>,<br />所以它包含 <code>JavaScript</code> 中许多通用的动能</p><ul><li><p>.toString()</p></li><li><p>.valueOf()</p></li><li><p>.hasOwnProperty()</p></li><li><p>.isPrototypeOf()</p></li></ul><h2 id="属性设置和屏蔽"><a class="markdownIt-Anchor" href="#属性设置和屏蔽"></a> 属性设置和屏蔽</h2><p>我们完整的讲一下给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>如果 <code>myObject</code> 对象中包含名为 <code>foo</code> 的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p></li><li><p>如果 <code>foo</code> 不是直接存在于 <code>myObject</code> 中， <code>[[Prototype]]</code> 链就会被遍历，类似 <code>[[Get]]</code> 操作。 如果原型链上找不到 <code>foo</code> ， <code>foo</code> 就会被直接添加到 <code>myObject</code> 上。</p></li><li><p><strong>然后，如果 <code>foo</code> 存在于原型链上层，赋值语句 <code>myObject.foo = 'bar'</code> 的行为就会有些不同（而且可能出任意料）</strong></p></li></ul><p><strong>如果属性名 <code>foo</code> 既出现在 <code>myObject</code> 中也出现在 <code>myObject</code> 的 <code>[[Prototype]]</code> 链上层，那么就会发生<code>屏蔽</code>。 <code>myObject</code> 中包含的 <code>foo</code> 属性会屏蔽原型链上层的所有 <code>foo</code> 属性，因为 <code>myObject.foo</code> 总是会选择原型链中最底层的 <code>foo</code> 属性</strong></p><p>让我们来分析下 属性屏蔽</p><p>如果 <code>foo</code> 不存在与 <code>myObject</code> 中而是存在于原型链上层时 <code>myObject.foo = 'bar'</code> 会出现的三种情况。</p><ul><li><p>如果在 <code>[[Prototype]]</code> 链上层存在名为 <code>foo</code> 的普通数据访问属性，并且没有被标记为只读 ( writable:false )， 那就会直接在 <code>myObject</code> 中添加一个名为 <code>foo</code> 的新属性，它是屏蔽属性。</p></li><li><p>如果在 <code>[[Prototype]]</code> 链上层存在 <code>foo</code> ，但是它被标记为只读 ( writable:false )，那么无法修改已有属性或者在 <code>myObject</code> 上创建屏蔽属性。 如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽</p></li><li><p>如果在 <code>[[Prototype]]</code> 链上存在 <code>foo</code> 并且它是一个 <code>setter</code>，那就一定会调用这个 <code>setter</code>。 <code>foo</code> 不会被添加到（或者说屏蔽于）<code>myObject</code>。也不会重新定义 <code>foo</code> 这个 <code>setter</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;prototype&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#prototype&quot;&gt;&lt;/a&gt; Prototype&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://zekiyjw.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="你不知道的JavaScript-上卷" scheme="https://zekiyjw.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>Javascript对象不变性</title>
    <link href="https://zekiyjw.github.io/2022/08/24/Javascript%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%98%E6%80%A7/"/>
    <id>https://zekiyjw.github.io/2022/08/24/Javascript%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%98%E6%80%A7/</id>
    <published>2022-08-24T02:19:34.000Z</published>
    <updated>2022-08-24T02:19:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不变性"><a class="markdownIt-Anchor" href="#不变性"></a> 不变性</h1><p><strong>有时候你会希望属性或者对象是不可改变（无论有意还是无意的）。</strong></p><p><strong>很重要的一点，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象（数组，对象，函数等），其他对象的内容不受影响，仍然是可变的。</strong></p><p>*在 JavaScript 中很少需要深不可变性，有些特殊情况可能需要这样做。如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计。</p><h2 id="属性描述符"><a class="markdownIt-Anchor" href="#属性描述符"></a> 属性描述符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 属性描述符</span></span><br><span class="line">var myObject = &#123;</span><br><span class="line">a:2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(myObject, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># configurable: true // 是否可配置</span></span><br><span class="line"><span class="comment"># enumerable: true   // 是否可枚举</span></span><br><span class="line"><span class="comment"># value: 2           // 属性值</span></span><br><span class="line"><span class="comment"># writable: true     // 是否可写</span></span><br></pre></td></tr></table></figure><h2 id="对象常量"><a class="markdownIt-Anchor" href="#对象常量"></a> 对象常量</h2><p>结合<code>writable:false</code>和<code>configurable:false</code>就可以创建一个真正的常量属性（不可修改，重定义或删除）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 属性描述符</span></span><br><span class="line">var myObject = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, <span class="string">&quot;FAVORITE_NUMBER&quot;</span>, &#123;</span><br><span class="line">value: 42,</span><br><span class="line">writable: <span class="literal">false</span>,</span><br><span class="line">configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="禁止扩展"><a class="markdownIt-Anchor" href="#禁止扩展"></a> 禁止扩展</h2><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用<code>Object.preventExtensions(..)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(myObject);</span><br><span class="line"></span><br><span class="line">myObject.b = 3;</span><br><span class="line">myObject.b; // undefined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非严格模式，创建属性b会静默失败</span></span><br><span class="line"><span class="comment"># 严格模式，会抛出TypeError错误</span></span><br></pre></td></tr></table></figure><h2 id="密封"><a class="markdownIt-Anchor" href="#密封"></a> 密封</h2><p><code>Object.seal(..)</code>会创建一个“密封”对象，这个方法实际上会在一个现有对象上调用<code>Object.preventExtensions(..)</code>并把所有现有属性标记为<code>configurable:false</code>。</p><p>密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（但是可修改属性的值）。、</p><h2 id="冻结"><a class="markdownIt-Anchor" href="#冻结"></a> 冻结</h2><p><code>Object.freeze(..)</code>会创建一个冻结对象，这个方法会在一个现有对象上调用<code>Object.seal(..)</code>并把所有“数据访问”属性标记为<code>writable:false</code>，这样就无法修改他们的值。</p><p>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（如上文所述，这个对象引用的其他对象是不受影响的）。</p><p>你可以“深度冻结”一个对象，具体方法：首先<code>Object.freeze(..)</code>，然后遍历它引用的所有对象并在这些对象上调用<code>Object.freeze(..)</code>。但是一定要小心，因为这样做，可能在无意中冻结其他共享对象!!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 深度冻结</span></span><br><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">Object.freeze(obj);</span><br><span class="line">Object.keys(obj).forEach((key,i)=&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(typeof obj[key] === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">constantize( obj[key] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;不变性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#不变性&quot;&gt;&lt;/a&gt; 不变性&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;有时候你会希望属性或者对象是不可改变（无论有意还是无意的）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很重要的一点</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://zekiyjw.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="你不知道的JavaScript-上卷" scheme="https://zekiyjw.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>为什么0.1+0.2不等于0.3</title>
    <link href="https://zekiyjw.github.io/2022/08/11/%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/"/>
    <id>https://zekiyjw.github.io/2022/08/11/%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/</id>
    <published>2022-08-11T02:40:35.000Z</published>
    <updated>2022-08-11T02:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3</span><br><span class="line"><span class="comment"># false</span></span><br><span class="line"></span><br><span class="line">0.1 + 0.2 = 0.30000000000000004</span><br></pre></td></tr></table></figure><p><strong>0.1 加 0.2 为什么就不等于 0.3 昵？要回答这个问题，得先了解计算机内部是如何表示数的。</strong></p><h1 id="计算机内部如何表示数"><a class="markdownIt-Anchor" href="#计算机内部如何表示数"></a> 计算机内部如何表示数</h1><p>我们都知道，计算机用位来储存及处理数据。每一个二进制数（二进制串）都一一对应一个十进制数。</p><ul><li>十进制整数转二进制方法是：除 2 取余</li><li>十进制小数转二进制方法是：乘 2 取整</li></ul><br /><p><strong>十进制 0.1 转换成二进制，乘 2 取整过程：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 * 2 = 0.2 <span class="comment"># 0</span></span><br><span class="line">0.2 * 2 = 0.4 <span class="comment"># 0</span></span><br><span class="line">0.4 * 2 = 0.8 <span class="comment"># 0</span></span><br><span class="line">0.8 * 2 = 1.6 <span class="comment"># 1</span></span><br><span class="line">0.6 * 2 = 1.2 <span class="comment"># 1</span></span><br><span class="line">0.2 * 2 = 0.4 <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>从上面可以看出，0.1 的二进制格式是：0.0001100011…。这是一个二进制无限循环小数，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？</p><p>答案是：在某个精度点直接舍弃。当然，代价就是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1。当代码被编译或解释后，0.1 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于 0.3 的原因。</p><p>有误差的两个数，其计算的结果，当然就很可能与我们期望的不一样了。注意前面的这句话中的“很可能”这三个字？为啥是很可能昵？</p><br /><h1 id="01-01-为什么等于-02"><a class="markdownIt-Anchor" href="#01-01-为什么等于-02"></a> 0.1 + 0.1 为什么等于 0.2</h1><p>答案是：两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。</p><p>又如，对于 0.1 + 0.3 ，结果其实并不是 0.4，但 0.4 是最接近真实结果的数，比其它任何浮点数都更接近。许多语言也就直接显示结果为 0.4 了，而不展示一个浮点数的真实结果了。</p><p>另外要注意，二进制能精确地表示位数有限且分母是 2 的倍数的小数，比如 0.5，0.5 在计算机内部就没有舍入误差。所以 0.5 + 0.5 === 1</p><br /><h1 id="计算机这样胡乱舍入能满足所有的计算需求吗"><a class="markdownIt-Anchor" href="#计算机这样胡乱舍入能满足所有的计算需求吗"></a> 计算机这样胡乱舍入，能满足所有的计算需求吗</h1><p>我们看两个现实的场景：</p><p>对于一个修建铁路的工程师而言，10 米宽，还是 10.0001 米宽并没有什么不同。铁路工程师就不需要这么高 0.x 这样的精度<br />对于芯片设计师，0.0001 米就会是一个巨大不同，他也永远不用处理超过 0.1 米距离<br />不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在。10.0001 与 10.001 在铁路工程师看来都是合格的。</p><p>虽然允许误差存在，但程序员在使用浮点数进行计算或逻辑处理时，不注意，就可能出问题。记住，永远不要直接比较两个浮点的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 0.1</span><br><span class="line">var b = 0.2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a + b === 0.3) &#123;</span><br><span class="line">  <span class="comment"># doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="js中如何进入浮点数运算"><a class="markdownIt-Anchor" href="#js中如何进入浮点数运算"></a> JS中如何进入浮点数运算</h1><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52;</p><h2 id="将浮点运算转换成整数计算"><a class="markdownIt-Anchor" href="#将浮点运算转换成整数计算"></a> 将浮点运算转换成整数计算</h2><p>整数是完全精度的，不存在舍入误差。例如，一些关于人民币的运算，都会以分为基本单位，计算采用分，展示再转换成元。当然，这样也有一些问题，会带来额外的工作量，如果那天人民币新增了一个货币单位，对系统的扩展性也会有考验。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">sum</span> = 0.1 + 0.2;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">sum</span> = ((0.1 * 100) + (0.2 * 100)) / 100</span><br></pre></td></tr></table></figure><h2 id="使用bignumber进行运算"><a class="markdownIt-Anchor" href="#使用bignumber进行运算"></a> 使用bignumber进行运算</h2><p>bignumber.js会在一定精度内，让浮点数计算结果符合我们的期望。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> x = new BigNumber(0.1);</span><br><span class="line">  <span class="built_in">let</span> y = new BigNumber(0.2)</span><br><span class="line">  <span class="built_in">let</span> z = new BigNumber(0.3)</span><br><span class="line"></span><br><span class="line">  console.log(z.equals(x.add(y))) // 0.3 === 0.1 + 0.2, <span class="literal">true</span></span><br><span class="line">  console.log(z.minus(x).equals(y)) // <span class="literal">true</span></span><br><span class="line">  console.log(z.minus(y).equals(x)) // <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="es6-numberepsilon"><a class="markdownIt-Anchor" href="#es6-numberepsilon"></a> ES6 <code>Number.EPSILON</code></h2><p>在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> numberepsilon(arg1, arg2)&#123; </span><br><span class="line">    <span class="built_in">return</span> Math.abs(arg1 - arg2) &lt; Number.EPSILON;</span><br><span class="line">&#125; </span><br><span class="line">console.log(numberepsilon(0.1 + 0.2, 0.3)); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><ul><li>为什么0.1 + 0.2 不等于0.3。因为计算机不能精确表示0.1， 0.2这样的浮点数，计算时使用的是带有舍入误差的数</li><li>并不是所有的浮点数在计算机内部都存在舍入误差，比如0.5就没有舍入误差</li><li>具有舍入误差的运算结可能会符合我们的期望，原因可能是“负负得正”</li><li>怎么办？1个办法是使用整型代替浮点数计算；2是不要直接比较两个浮点数，而应该使用bignumber.js这样的浮点数运算库</li></ul><br /><p><strong>*本文借鉴于<a href="https://segmentfault.com/a/1190000012175422" traget="_blank">为什么0.1+0.2不等于0.3</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="面试" scheme="https://zekiyjw.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zekiyjw.github.io/2022/08/08/hello-world/"/>
    <id>https://zekiyjw.github.io/2022/08/08/hello-world/</id>
    <published>2022-08-08T13:49:22.956Z</published>
    <updated>2022-08-08T13:49:22.956Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="https://zekiyjw.github.io/2022/08/02/React/"/>
    <id>https://zekiyjw.github.io/2022/08/02/React/</id>
    <published>2022-08-02T02:35:49.000Z</published>
    <updated>2022-08-02T02:35:49.000Z</updated>
    
    
    
    
    <category term="面试" scheme="https://zekiyjw.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Code Review 实践</title>
    <link href="https://zekiyjw.github.io/2022/08/01/Code-Review/"/>
    <id>https://zekiyjw.github.io/2022/08/01/Code-Review/</id>
    <published>2022-08-01T02:52:34.000Z</published>
    <updated>2022-08-01T02:52:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="locationreplace-和-locationhref-的使用区别"><a class="markdownIt-Anchor" href="#locationreplace-和-locationhref-的使用区别"></a> <code>location.replace</code> 和 <code>location.href</code> 的使用区别</h1><ul><li><code>Location.replace()</code> 方法以给定的 URL 来替换当前的资源。 与 <code>assign()</code> 方法 不同的是，调用 <code>replace()</code> 方法后，当前页面不会保存到会话历史中（session <code>History</code>），这样，用户点击回退按钮时，将不会再跳转到该页面。</li><li><code>Location.href()</code> 是一个字符串化转换器 (stringifier), 返回一个包含了完整 URL 的 <code>USVString</code> 值，且允许 href 的更新。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A B C 三个页面</span></span><br><span class="line"><span class="comment"># A 跳转 B</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># B =&gt; C  location.replace(&quot;/C&quot;)  直接将C页替换当前B页，B页不会保存到会话历史中，回退的时候是显示A页</span></span><br><span class="line"><span class="comment"># B =&gt; C  location.href(&quot;/C&quot;)     回退还是B页</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注：使用 replace 会导致无法后退回当前页</strong></p><br /><h1 id="正则判断没有对用户可能输入的特殊符号进行转义"><a class="markdownIt-Anchor" href="#正则判断没有对用户可能输入的特殊符号进行转义"></a> 正则判断没有对用户可能输入的特殊符号进行转义</h1><p><strong>正则表达式中有些字符具有特殊的含义，如果在匹配中要用到它本来的含义，需要进行转义（在其前面加一个\）。如：* . ? + $ ^ [ ] ( ) { } | \ /</strong></p><br /><h1 id="table-行点击事件的处理"><a class="markdownIt-Anchor" href="#table-行点击事件的处理"></a> Table 行点击事件的处理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例代码想实现点击表格行跳转页面效果，但是会导致一些鼠标操作被覆盖</span></span><br><span class="line"></span><br><span class="line">&lt;Table</span><br><span class="line">rowKey=<span class="string">&quot;id&quot;</span></span><br><span class="line">columns=&#123;columns&#125;</span><br><span class="line">dataSource=&#123;data&#125;</span><br><span class="line">onChange=&#123;handleTableChange&#125;</span><br><span class="line">onRow=&#123;(record)=&gt;&#123;</span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">onClick:()=&gt;&#123;</span><br><span class="line">History.push(`/path/<span class="variable">$&#123;record.id&#125;</span>`)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接监听onClick事件，会导致文本复制，点击图片等操作，也会触发跳转。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 复制文本与点击跳转冲突</span></span><br><span class="line"><span class="comment"># 解决方案： 执行点击逻辑之前，判断是否选中内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 点击图片与点击跳转冲突</span></span><br><span class="line"><span class="comment"># 解决方案： 判断 e.target == rowEIObj 即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 将row单独作为一个组件来处理，或者在row的最外层包裹一个组件</span></span><br></pre></td></tr></table></figure><br /><h1 id="在一个较大的组件内需要注意输入组件导致的重渲染问题"><a class="markdownIt-Anchor" href="#在一个较大的组件内需要注意输入组件导致的重渲染问题"></a> 在一个较大的组件内，需要注意输入组件导致的重渲染问题</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">&lt;Input onChange=&#123;e=&gt;setInputValue(e.target.value)&#125; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">&lt;Table /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 像input这种组件可以抽出来作为一个单独的组件，避免每次触发onChange都会导致整个组件重新渲染</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组件的onChange不要去render整个组件，可以理解为非受控组件， 状态自己控制自己， 每次改变状态传给table，或者提交的时候统一收集。不然的话 行太多，会引发性能问题</span></span><br></pre></td></tr></table></figure><br /><h1 id="维护好项目内的公共组件"><a class="markdownIt-Anchor" href="#维护好项目内的公共组件"></a> 维护好项目内的公共组件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># components/Header.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 公共组件需要在注释或readme.md上说明改组件的作用和api</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;locationreplace-和-locationhref-的使用区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#locationreplace-和-locationhref-的使用区别&quot;&gt;&lt;/a&gt; &lt;code&gt;location.</summary>
      
    
    
    
    <category term="Code Review" scheme="https://zekiyjw.github.io/categories/Code-Review/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript事件委托</title>
    <link href="https://zekiyjw.github.io/2022/07/13/JavaScript%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>https://zekiyjw.github.io/2022/07/13/JavaScript%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</id>
    <published>2022-07-13T02:45:34.000Z</published>
    <updated>2022-07-13T02:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件委托"><a class="markdownIt-Anchor" href="#事件委托"></a> 事件委托</h2><strong><code>事件委托</code>又称<code>事件代理</code>是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，实现处理程序对多个子孙级元素的某类型事件管理。通俗来说，就是把任意个子孙级元素的响应事件的函数委托到另一个元素（通常为委托元素的祖先元素）</strong><h3 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul class=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    &lt;li class=<span class="string">&quot;item&quot;</span>&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li class=<span class="string">&quot;item&quot;</span>&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li class=<span class="string">&quot;item&quot;</span>&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li class=<span class="string">&quot;item&quot;</span>&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li class=<span class="string">&quot;item&quot;</span>&gt;5&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="普通写法"><a class="markdownIt-Anchor" href="#普通写法"></a> 普通写法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const list = document.querySelector(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line">const items = list.getElementsByClassName(<span class="string">&#x27;item&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> li of items)&#123;</span><br><span class="line">li.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">console.log(<span class="string">&#x27;the content is:&#x27;</span>, li.innerHTML);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如列表的li较少，这种写法没有问题。如果列表很长，1000，10000，那这种写法就非常消耗性能，需要不断的去给元素绑定，解绑</span></span><br></pre></td></tr></table></figure><h3 id="使用事件委托将绑定委托给祖先元素"><a class="markdownIt-Anchor" href="#使用事件委托将绑定委托给祖先元素"></a> 使用事件委托，将绑定委托给祖先元素</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const list = document.querySelector(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"></span><br><span class="line">list.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">const event = e || window.event;</span><br><span class="line">const target = event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(target.nodeName.toLocaleLowerCase() === <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">console.log(<span class="string">&#x27;the content is:&#x27;</span>, target.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>假如点击的是li标签中的子元素，那么上述的判断就有问题。详见<a href="https://zhuanlan.zhihu.com/p/26536815">JavaScript 事件委托详解</a></strong></p><h3 id="事件绑定解决方案"><a class="markdownIt-Anchor" href="#事件绑定解决方案"></a> 事件绑定解决方案</h3><ul><li>绑定事件越多，浏览器内存占用越大，严重影响性能</li><li>局部刷新的盛行，导致每次加载完，都要重新绑定事件</li><li>部分浏览器移除元素时，绑定的事件并没有被及时移除，导致的内存泄露，严重影响性能</li><li>大部分局部刷新，只是显示的数据，而操作却是大部分相同的，重复绑定，会导致到码的耦合性过大，严重影响后期的维护</li></ul><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>减少内存消耗。DOM树层级较深，绑定事件越多，浏览器内存占用越大，严重影响性能。</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ul><li><code>onfoucus</code>、<code>onblur</code>之类的事件本身没有事件冒泡机制，无法使用事件委托</li><li><code>mouseover</code>、<code>mousemove</code>这样的鼠标、滚轮等事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也不适合事件委托</li></ul><h3 id="优化手段"><a class="markdownIt-Anchor" href="#优化手段"></a> 优化手段</h3><ul><li>只在必须的地方使用事件委托，比如网络请求的局部刷新区域</li><li>尽量减少绑定的层级，不在<code>&lt;body&gt;</code>元素上进行绑定</li><li>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中，由这个事件委托的回调，来进行分发</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件委托&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#事件委托&quot;&gt;&lt;/a&gt; 事件委托&lt;/h2&gt;
&lt;strong&gt;
&lt;code&gt;事件委托&lt;/code&gt;又称&lt;code&gt;事件代理&lt;/code&gt;是利用事件冒泡的特性，将本应该绑定在多个元素上的</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://zekiyjw.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>for循环实现每隔一秒打印下标</title>
    <link href="https://zekiyjw.github.io/2022/07/05/for%E5%BE%AA%E7%8E%AF%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0%E4%B8%8B%E6%A0%87/"/>
    <id>https://zekiyjw.github.io/2022/07/05/for%E5%BE%AA%E7%8E%AF%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0%E4%B8%8B%E6%A0%87/</id>
    <published>2022-07-05T08:49:23.000Z</published>
    <updated>2022-07-05T08:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i * 1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大家猜猜最后打印得结果是什么 0,1,2,3,4,5 ?</span></span><br></pre></td></tr></table></figure><p>上图</p><image src="/images/07-05/01.png" alt="for循环实现每隔一秒打印下标 01" /><p><strong>为什么呢? 这里涉及到<code>作用域</code> <code>事件循环</code>等知识点</strong></p><h2 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h2><p>引用《你不知道的 Javascript》中的一个比喻，可以把作用域链想象成一座高楼，第一层代表当前执行作用域，楼的顶层代表全局作用域。我们在查找变量时会先在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有就继续向上找。依次类推。到达顶层后（全局作用域），可能找到了你所需要的变量，也可能没找到，但无论如何查找过程都将停止。</p><h2 id="事件循环"><a class="markdownIt-Anchor" href="#事件循环"></a> 事件循环</h2><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JavaScript 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><ul><li><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p></li><li><p>（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</p></li><li><p>（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p></li><li><p>（4）主线程不断重复上面的第三步。</p></li></ul><p>只要主线程空了，就会去读取&quot;任务队列&quot;，这就是 JavaScript 的运行机制。这个过程会不断重复。</p><hr /><p><strong>在了解这两个知识点后，让我们回到题目中</strong></p><ul><li>首先是一个 for 循环，var 声明一个变量 i; var 申明的变量是全局变量 记住这一点</li><li>然后来到 for 循环内容，是一个延时器，setTimeout 实际就是一个异步任务，它会被放在任务队列，在等待主线程执行完后才会执行它</li></ul><p>有的同学就很聪明说，那我把 setTimeout 的延时设置为 0，立即执行就可以了吗? 不行!</p><p>上代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><image src="/images/07-05/02.png" alt="for循环实现每隔一秒打印下标 02" /><strong>看到了吗？是先执行的for循环，然后再执行的setTimeout。因为setTimeout实际上是在任务队列的尾部添加了一个事件。因此要等到同步任务和任务队列现有的事件都执行完，才会得到执行。并且i是由var全局声明的，等到延时器执行时，它已经是6了。</strong><h2 id="知道是什么问题造成的那就好解决了"><a class="markdownIt-Anchor" href="#知道是什么问题造成的那就好解决了"></a> 知道是什么问题造成的，那就好解决了</h2><p><strong>一、改 <code>var</code> 为 <code>let</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量</p><p><strong>二、立即执行表达式函数(IIFE)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(i)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;, i * 1000)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三、引入bind函数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    setTimeout(<span class="keyword">function</span>(i)&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;.<span class="built_in">bind</span>(null, i), i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、利用setTimeout第三个参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    setTimeout(<span class="keyword">function</span>(i)&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i * 1000, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文借鉴于<a href="https://www.jianshu.com/p/3e482748369d?from=groupmessage">彻底理解setTimeout()</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="面试" scheme="https://zekiyjw.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="编程题" scheme="https://zekiyjw.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript如何判断移动设备</title>
    <link href="https://zekiyjw.github.io/2022/07/04/JavaScript%E5%88%A4%E6%96%AD%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E4%B8%BA%E6%89%8B%E6%9C%BA%E7%AB%AF/"/>
    <id>https://zekiyjw.github.io/2022/07/04/JavaScript%E5%88%A4%E6%96%AD%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E4%B8%BA%E6%89%8B%E6%9C%BA%E7%AB%AF/</id>
    <published>2022-07-04T03:24:05.000Z</published>
    <updated>2022-07-04T03:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文给大家提供五种解决方案</p><h2 id="一-windownavigator"><a class="markdownIt-Anchor" href="#一-windownavigator"></a> 一、window.navigator</h2><ul><li><strong><code>window.navigator.userAgent</code>：汉译用户代理。它首部包含了一个特征字符，可以让网络协议的端来识别发送请求的代理软件的应用程序类型、操作部、用户软件以及版本号</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userAgent: <span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1&quot;</span></span><br></pre></td></tr></table></figure><p>我们通过<code>window.navigator.userAgent</code>属性拿到这个字符串，只要里面包含<code>Android</code>、<code>iPhone</code>、<code>iPad</code>、<code>iPod</code>、<code>Symbian</code>等关键字，就可以认定是移动设备<br /><small>Tips:<a href="https://baike.baidu.com/item/%E5%A1%9E%E7%8F%AD%E7%B3%BB%E7%BB%9F/8506777?fromtitle=symbian&fromid=264891&fr=aladdin">什么是 Symbian?</a></small></p><p>上代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const isMobile = () =&gt; &#123;</span><br><span class="line">  <span class="built_in">let</span> u = window.navigator.userAgent;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -1 ||</span><br><span class="line">    u.indexOf(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -1 ||</span><br><span class="line">    u.indexOf(<span class="string">&#x27;iPad&#x27;</span>) &gt; -1 ||</span><br><span class="line">    u.indexOf(<span class="string">&#x27;iPod&#x27;</span>) &gt; -1 ||</span><br><span class="line">    u.indexOf(<span class="string">&#x27;Symbian&#x27;</span>) &gt; -1</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># But! userAgent 是可以被修改的</span></span><br></pre></td></tr></table></figure><p><small>具体操作请看这篇文章<a href="https://dysaniazzz.github.io/2019/06/06/useragent/">Chrome 浏览器如何修改 User-Agent</a></small></p><ul><li><strong><code>window.navigator.userAgentData</code>：将 user agent 字符串解析为一个对象，该对象的<code>mobile</code>属性，返回一个布尔值，表示用户是否使用移动设备</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 苹果的 Safari 浏览器和 Firefox 浏览器都不支持这个属性</span></span><br><span class="line">const isMobile = navigator.userAgentData.mobile;</span><br></pre></td></tr></table></figure><p><small>具体情况可以查看 <a href="https://caniuse.com/mdn-api_navigator_useragentdata">Caniuse 网站</a>。</small></p><ul><li><strong><code>navigator.platform</code>：它返回一个字符串，表示用户的操作系统</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (/Android|iPhone|iPad|iPod/i.test(navigator.platform)) &#123;</span><br><span class="line">  <span class="comment"># 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-侦听屏幕宽度以及设备指针"><a class="markdownIt-Anchor" href="#二-侦听屏幕宽度以及设备指针"></a> 二、侦听屏幕宽度以及设备指针</h2><ul><li><code>window.screen</code>对象返回用户设备的屏幕信息，该对象的 width 属性是屏幕宽度（单位为像素）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对手机横屏失效</span></span><br><span class="line"><span class="keyword">if</span> (window.screen.width &lt; 500) &#123;</span><br><span class="line">  <span class="comment"># 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>window.matchMedia()</code>方法接收一个 CSS 的 media query 语句作为参数，判断这个语句是否生效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不严谨，针对手机模拟器侦听为true</span></span><br><span class="line"><span class="built_in">let</span> isMobile = window.matchMedia(<span class="string">&quot;only screen and (max-width: 760px)&quot;</span>).matches;</span><br></pre></td></tr></table></figure><p><strong>如果屏幕宽度<code>window.screen.width</code>小于 500 像素，就认为是手机。如果手机横屏使用就识别不了~~</strong></p><h2 id="三-侦测屏幕方向-windoworientation-iphone-的-safari-浏览器不支持该属性"><a class="markdownIt-Anchor" href="#三-侦测屏幕方向-windoworientation-iphone-的-safari-浏览器不支持该属性"></a> 三、侦测屏幕方向 window.orientation (iPhone 的 Safari 浏览器不支持该属性)</h2><strong>手机屏幕可以随时更改方向，桌面设备做不到。`window.orientation`属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回`undefined`。</strong><p>上代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof window.orientation !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment"># 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-touch-事件-推荐"><a class="markdownIt-Anchor" href="#四-touch-事件-推荐"></a> 四、touch 事件 (推荐)</h2><p><strong>手机浏览器的 DOM 元素可以通过<code>ontouchstart</code>属性，为<code>touch</code>事件指定监听函数。桌面设备没有这个属性</strong></p><p>上代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">isMobile</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="string">&quot;ontouchstart&quot;</span> <span class="keyword">in</span> document.documentElement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">isMobile</span></span>()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        document.createEvent(<span class="string">&quot;TouchEvent&quot;</span>); <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-工具包"><a class="markdownIt-Anchor" href="#五-工具包"></a> 五、工具包</h2><p><strong>直接引用别人写好的工具包，这里推荐<code>react-device-detect</code>，它支持多种粒度的设备侦测</strong></p><p>上代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;isMobile&#125; from <span class="string">&#x27;react-device-detect&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isMobile) &#123;</span><br><span class="line">    <span class="comment"># 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文借鉴于阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2021/09/detecting-mobile-browser.html">JavaScript 侦测手机浏览器的五种方法</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文给大家提供五种解决方案&lt;/p&gt;
&lt;h2 id=&quot;一-windownavigator&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-windownavigator&quot;&gt;&lt;/a&gt; 一、window.navigator&lt;/h2&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://zekiyjw.github.io/categories/JavaScript/"/>
    
    
    <category term="自定义工具函数" scheme="https://zekiyjw.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>React Class类名冲突、重复样式怎么办?</title>
    <link href="https://zekiyjw.github.io/2022/06/29/React%20Class%E7%B1%BB%E5%90%8D%E5%86%B2%E7%AA%81%E3%80%81%E9%87%8D%E5%A4%8D%E6%A0%B7%E5%BC%8F%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://zekiyjw.github.io/2022/06/29/React%20Class%E7%B1%BB%E5%90%8D%E5%86%B2%E7%AA%81%E3%80%81%E9%87%8D%E5%A4%8D%E6%A0%B7%E5%BC%8F%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2022-06-29T09:29:27.000Z</published>
    <updated>2022-07-01T09:29:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文给大家提供两种解决方案</p><h2 id="css-in-js"><a class="markdownIt-Anchor" href="#css-in-js"></a> CSS in Js</h2><p><strong>它是一种模式，主要借助第三方库生成<code>随机类名称</code>来建立一种局部类名的方式。</strong></p><ul><li>第一步安装 <code>styled-components</code> 库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S styed-components</span><br></pre></td></tr></table></figure><ul><li>第二步 引入 <code>styled-components</code>，并在Js中写Css代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import styled from <span class="string">&quot;styled-components&quot;</span>;</span><br><span class="line"></span><br><span class="line">// 声明一个公共样式</span><br><span class="line">const style_div = &#123;</span><br><span class="line">  width: 100,</span><br><span class="line">  height: 100,</span><br><span class="line">  color: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">  textAlign: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">  lineHeight: <span class="string">&quot;100px&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 声明一个带背景色的DivA</span><br><span class="line">const DivA = styled.div`</span><br><span class="line">  background-color: red;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 声明一个带背景色的DivB</span><br><span class="line">const DivB = styled.div`</span><br><span class="line">  background-color: green;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;DivA style=&#123;style_div&#125;&gt;DivA&lt;/DivA&gt;</span><br><span class="line">      &lt;DivB style=&#123;style_div&#125;&gt;DivB&lt;/DivB&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CSS in Js</code>效果图<br /><image src="/images/06-29/01.png" alt="" /></li></ul><p><strong>Tips:要避免在render方法中声明样式化组件，这样程序虽然不会报错，但是会引起性能问题，引起组件不必要的渲染！</strong></p><!-- ## 总结：通过引入 `styled-components` 包，可以创建样式，也可以直接创建元素，并且类名是随机生成的，这就避免了类名重复，样式污染的问题。 --><h2 id="css-module"><a class="markdownIt-Anchor" href="#css-module"></a> CSS Module</h2><p><strong>在使用create-react-app脚手架创建的项目后，该项目是支持css-module的</strong></p><p><strong>样式文件的名称必须以<code>xxx.module.css</code>或者<code>xxx.module.scss</code>的形式命名；例如<code>styles.module.css</code></strong></p><ul><li>第一步新建<code>styles.module.css</code>文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.pink_box &#123;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.skyblue_box&#123;</span><br><span class="line">  background-color: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二步引入<code>styles.module.css</code>,className以变量引入的方式进行添加,例如:className ={styles.counter}</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import styles from <span class="string">&quot;./styles.module.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;div className=&#123;styles.pink_box&#125;&gt;DivA&lt;/div&gt;</span><br><span class="line">      &lt;div className=&#123;styles.skyblue_box&#125;&gt;DivB&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CSS Module</code>效果图<br /><image src="/images/06-29/02.png" alt="" /></li></ul><h2 id="css工程化"><a class="markdownIt-Anchor" href="#css工程化"></a> CSS工程化</h2><p><strong>随着项目越来越大，人越来越多，命名慢慢成为问题，类名重复，样式污染。CSS社区也诞生了相应的模块化解决方案</strong></p><ul><li>CSS命名方法论：通过人工的方式来约定命名规则</li><li>CSS Module: 一个css文件就是一个独立的模块</li><li>CSS in Js: 在Js中写Css</li></ul><p><strong>总结：个人推荐<code>CSS Module</code>，因为功能简单，只加入了局部作用域和模块依赖，可以保证某个组件的样式，不会影响其他组件</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文给大家提供两种解决方案&lt;/p&gt;
&lt;h2 id=&quot;css-in-js&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#css-in-js&quot;&gt;&lt;/a&gt; CSS in Js&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;它是一种模式，主要借助第三方库生成&lt;code</summary>
      
    
    
    
    <category term="CSS" scheme="https://zekiyjw.github.io/categories/CSS/"/>
    
    
  </entry>
  
</feed>
