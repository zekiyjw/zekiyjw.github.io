{"meta":{"title":"张嘉桢の博客","subtitle":"","description":"","author":"John Doe","url":"https://zekiyjw.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-02-27T06:50:44.694Z","updated":"2023-02-27T06:50:44.694Z","comments":false,"path":"/404.html","permalink":"https://zekiyjw.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2023-02-27T06:50:44.694Z","updated":"2023-02-27T06:50:44.694Z","comments":false,"path":"categories/index.html","permalink":"https://zekiyjw.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-02-27T06:50:44.686Z","updated":"2023-02-27T06:50:44.686Z","comments":false,"path":"about/index.html","permalink":"https://zekiyjw.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-02-27T06:50:44.686Z","updated":"2023-02-27T06:50:44.686Z","comments":false,"path":"books/index.html","permalink":"https://zekiyjw.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-27T06:50:44.687Z","updated":"2023-02-27T06:50:44.687Z","comments":false,"path":"tags/index.html","permalink":"https://zekiyjw.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-27T06:50:44.677Z","updated":"2023-02-27T06:50:44.677Z","comments":false,"path":"repository/index.html","permalink":"https://zekiyjw.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-02-27T06:50:44.687Z","updated":"2023-02-27T06:50:44.687Z","comments":true,"path":"links/index.html","permalink":"https://zekiyjw.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"原型","slug":"原型","date":"2022-09-02T07:54:39.000Z","updated":"2022-09-02T07:54:39.000Z","comments":true,"path":"2022/09/02/原型/","link":"","permalink":"https://zekiyjw.github.io/2022/09/02/%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"Prototype 12345678var anotherObject = &#123; a: 2&#125;;# 创建一个关联到 anotherObject 的对象var myObject = Object.create( anotherObject );myObject.a # 2 对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链: Object.create()它会创建一个对象并且把这个对象的 [[Prototype]] 关联到指定的对象 显然 myObject.a 并不存在，但是尽管如此，属性访问依然成功地（在 anotherObject 中）找到了值 2。 但是如果 anotherObject 中也找不到 a 并且 [[Prototype]] 链不为空的话，就会继续查找下去。 这个过程会持续到找到匹配的属性名或者查找完整条 [[Prototype]] 链。如果是后者的话， [[Get]] 操作的返回值是 undefined。 Object.Prototype 所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。 由于所有的 “ 普通 ” （内置，不是特定主机的扩展）对象都 “ 源于 ” （或者说把 [[Prototype]] 链的顶端设置为）这个 Object.prototype, 所以它包含 JavaScript 中许多通用的动能 .toString() .valueOf() .hasOwnProperty() .isPrototypeOf() 属性设置和屏蔽 我们完整的讲一下给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。 1myObject.foo = &#x27;bar&#x27;; 如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属性值。 如果 foo 不是直接存在于 myObject 中， [[Prototype]] 链就会被遍历，类似 [[Get]] 操作。 如果原型链上找不到 foo ， foo 就会被直接添加到 myObject 上。 然后，如果 foo 存在于原型链上层，赋值语句 myObject.foo = 'bar' 的行为就会有些不同（而且可能出任意料） 如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。 myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性 让我们来分析下 属性屏蔽 如果 foo 不存在与 myObject 中而是存在于原型链上层时 myObject.foo = 'bar' 会出现的三种情况。 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性，并且没有被标记为只读 ( writable:false )， 那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。 如果在 [[Prototype]] 链上层存在 foo ，但是它被标记为只读 ( writable:false )，那么无法修改已有属性或者在 myObject 上创建屏蔽属性。 如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽 如果在 [[Prototype]] 链上存在 foo 并且它是一个 setter，那就一定会调用这个 setter。 foo 不会被添加到（或者说屏蔽于）myObject。也不会重新定义 foo 这个 setter。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zekiyjw.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"你不知道的JavaScript-上卷","slug":"你不知道的JavaScript-上卷","permalink":"https://zekiyjw.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7/"}]},{"title":"Javascript对象不变性","slug":"Javascript对象不变性","date":"2022-08-24T02:19:34.000Z","updated":"2022-08-24T02:19:34.000Z","comments":true,"path":"2022/08/24/Javascript对象不变性/","link":"","permalink":"https://zekiyjw.github.io/2022/08/24/Javascript%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%98%E6%80%A7/","excerpt":"","text":"不变性 有时候你会希望属性或者对象是不可改变（无论有意还是无意的）。 很重要的一点，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象（数组，对象，函数等），其他对象的内容不受影响，仍然是可变的。 *在 JavaScript 中很少需要深不可变性，有些特殊情况可能需要这样做。如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计。 属性描述符 1234567891011# 属性描述符var myObject = &#123; a:2&#125;Object.getOwnPropertyDescriptor(myObject, &quot;a&quot;);# configurable: true // 是否可配置# enumerable: true // 是否可枚举# value: 2 // 属性值# writable: true // 是否可写 对象常量 结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改，重定义或删除） 12345678# 属性描述符var myObject = &#123;&#125;Object.defineProperty( myObject, &quot;FAVORITE_NUMBER&quot;, &#123; value: 42, writable: false, configurable: false&#125;) 禁止扩展 如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..) 1234567891011var myObject = &#123; a: 2&#125;Object.preventExtensions(myObject);myObject.b = 3;myObject.b; // undefined# 非严格模式，创建属性b会静默失败# 严格模式，会抛出TypeError错误 密封 Object.seal(..)会创建一个“密封”对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..)并把所有现有属性标记为configurable:false。 密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（但是可修改属性的值）。、 冻结 Object.freeze(..)会创建一个冻结对象，这个方法会在一个现有对象上调用Object.seal(..)并把所有“数据访问”属性标记为writable:false，这样就无法修改他们的值。 这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（如上文所述，这个对象引用的其他对象是不受影响的）。 你可以“深度冻结”一个对象，具体方法：首先Object.freeze(..)，然后遍历它引用的所有对象并在这些对象上调用Object.freeze(..)。但是一定要小心，因为这样做，可能在无意中冻结其他共享对象!! 123456789# 深度冻结var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key,i)=&gt;&#123; if(typeof obj[key] === &#x27;object&#x27;)&#123; constantize( obj[key] ); &#125; &#125;)&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zekiyjw.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"你不知道的JavaScript-上卷","slug":"你不知道的JavaScript-上卷","permalink":"https://zekiyjw.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7/"}]},{"title":"为什么0.1+0.2不等于0.3","slug":"为什么0-1-0-2不等于0-3","date":"2022-08-11T02:40:35.000Z","updated":"2022-08-11T02:40:35.000Z","comments":true,"path":"2022/08/11/为什么0-1-0-2不等于0-3/","link":"","permalink":"https://zekiyjw.github.io/2022/08/11/%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/","excerpt":"","text":"12340.1 + 0.2 === 0.3# false0.1 + 0.2 = 0.30000000000000004 0.1 加 0.2 为什么就不等于 0.3 昵？要回答这个问题，得先了解计算机内部是如何表示数的。 计算机内部如何表示数 我们都知道，计算机用位来储存及处理数据。每一个二进制数（二进制串）都一一对应一个十进制数。 十进制整数转二进制方法是：除 2 取余 十进制小数转二进制方法是：乘 2 取整 十进制 0.1 转换成二进制，乘 2 取整过程： 123456780.1 * 2 = 0.2 # 00.2 * 2 = 0.4 # 00.4 * 2 = 0.8 # 00.8 * 2 = 1.6 # 10.6 * 2 = 1.2 # 10.2 * 2 = 0.4 # 0..... 从上面可以看出，0.1 的二进制格式是：0.0001100011…。这是一个二进制无限循环小数，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？ 答案是：在某个精度点直接舍弃。当然，代价就是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1。当代码被编译或解释后，0.1 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于 0.3 的原因。 有误差的两个数，其计算的结果，当然就很可能与我们期望的不一样了。注意前面的这句话中的“很可能”这三个字？为啥是很可能昵？ 0.1 + 0.1 为什么等于 0.2 答案是：两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。 又如，对于 0.1 + 0.3 ，结果其实并不是 0.4，但 0.4 是最接近真实结果的数，比其它任何浮点数都更接近。许多语言也就直接显示结果为 0.4 了，而不展示一个浮点数的真实结果了。 另外要注意，二进制能精确地表示位数有限且分母是 2 的倍数的小数，比如 0.5，0.5 在计算机内部就没有舍入误差。所以 0.5 + 0.5 === 1 计算机这样胡乱舍入，能满足所有的计算需求吗 我们看两个现实的场景： 对于一个修建铁路的工程师而言，10 米宽，还是 10.0001 米宽并没有什么不同。铁路工程师就不需要这么高 0.x 这样的精度 对于芯片设计师，0.0001 米就会是一个巨大不同，他也永远不用处理超过 0.1 米距离 不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在。10.0001 与 10.001 在铁路工程师看来都是合格的。 虽然允许误差存在，但程序员在使用浮点数进行计算或逻辑处理时，不注意，就可能出问题。记住，永远不要直接比较两个浮点的大小： 123456var a = 0.1var b = 0.2if (a + b === 0.3) &#123; # doSomething&#125; JS中如何进入浮点数运算 对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52; 将浮点运算转换成整数计算 整数是完全精度的，不存在舍入误差。例如，一些关于人民币的运算，都会以分为基本单位，计算采用分，展示再转换成元。当然，这样也有一些问题，会带来额外的工作量，如果那天人民币新增了一个货币单位，对系统的扩展性也会有考验。 123const sum = 0.1 + 0.2;const sum = ((0.1 * 100) + (0.2 * 100)) / 100 使用bignumber进行运算 bignumber.js会在一定精度内，让浮点数计算结果符合我们的期望。 123456789&#123; let x = new BigNumber(0.1); let y = new BigNumber(0.2) let z = new BigNumber(0.3) console.log(z.equals(x.add(y))) // 0.3 === 0.1 + 0.2, true console.log(z.minus(x).equals(y)) // true console.log(z.minus(y).equals(x)) // true&#125; ES6 Number.EPSILON 在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3 1234function numberepsilon(arg1, arg2)&#123; return Math.abs(arg1 - arg2) &lt; Number.EPSILON;&#125; console.log(numberepsilon(0.1 + 0.2, 0.3)); // true 小结 为什么0.1 + 0.2 不等于0.3。因为计算机不能精确表示0.1， 0.2这样的浮点数，计算时使用的是带有舍入误差的数 并不是所有的浮点数在计算机内部都存在舍入误差，比如0.5就没有舍入误差 具有舍入误差的运算结可能会符合我们的期望，原因可能是“负负得正” 怎么办？1个办法是使用整型代替浮点数计算；2是不要直接比较两个浮点数，而应该使用bignumber.js这样的浮点数运算库 *本文借鉴于为什么0.1+0.2不等于0.3","categories":[{"name":"面试","slug":"面试","permalink":"https://zekiyjw.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-08T13:49:22.956Z","updated":"2022-08-08T13:49:22.956Z","comments":true,"path":"2022/08/08/hello-world/","link":"","permalink":"https://zekiyjw.github.io/2022/08/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"React","slug":"React","date":"2022-08-02T02:35:49.000Z","updated":"2022-08-02T02:35:49.000Z","comments":true,"path":"2022/08/02/React/","link":"","permalink":"https://zekiyjw.github.io/2022/08/02/React/","excerpt":"","text":"","categories":[{"name":"面试","slug":"面试","permalink":"https://zekiyjw.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"Code Review 实践","slug":"Code-Review","date":"2022-08-01T02:52:34.000Z","updated":"2022-08-01T02:52:34.000Z","comments":true,"path":"2022/08/01/Code-Review/","link":"","permalink":"https://zekiyjw.github.io/2022/08/01/Code-Review/","excerpt":"","text":"location.replace 和 location.href 的使用区别 Location.replace() 方法以给定的 URL 来替换当前的资源。 与 assign() 方法 不同的是，调用 replace() 方法后，当前页面不会保存到会话历史中（session History），这样，用户点击回退按钮时，将不会再跳转到该页面。 Location.href() 是一个字符串化转换器 (stringifier), 返回一个包含了完整 URL 的 USVString 值，且允许 href 的更新。 123456# A B C 三个页面# A 跳转 B# B =&gt; C location.replace(&quot;/C&quot;) 直接将C页替换当前B页，B页不会保存到会话历史中，回退的时候是显示A页# B =&gt; C location.href(&quot;/C&quot;) 回退还是B页 注：使用 replace 会导致无法后退回当前页 正则判断没有对用户可能输入的特殊符号进行转义 正则表达式中有些字符具有特殊的含义，如果在匹配中要用到它本来的含义，需要进行转义（在其前面加一个\\）。如：* . ? + $ ^ [ ] ( ) { } | \\ / Table 行点击事件的处理 12345678910111213141516171819202122232425# 示例代码想实现点击表格行跳转页面效果，但是会导致一些鼠标操作被覆盖&lt;Table rowKey=&quot;id&quot; columns=&#123;columns&#125; dataSource=&#123;data&#125; onChange=&#123;handleTableChange&#125; onRow=&#123;(record)=&gt;&#123; return &#123; onClick:()=&gt;&#123; History.push(`/path/$&#123;record.id&#125;`) &#125; &#125; &#125;&#125; /&gt;# 直接监听onClick事件，会导致文本复制，点击图片等操作，也会触发跳转。## 复制文本与点击跳转冲突# 解决方案： 执行点击逻辑之前，判断是否选中内容## 点击图片与点击跳转冲突# 解决方案： 判断 e.target == rowEIObj 即可## 将row单独作为一个组件来处理，或者在row的最外层包裹一个组件 在一个较大的组件内，需要注意输入组件导致的重渲染问题 12345678910&lt;form&gt; &lt;Input onChange=&#123;e=&gt;setInputValue(e.target.value)&#125; /&gt;&lt;/form&gt;# ...&lt;Table /&gt;# 像input这种组件可以抽出来作为一个单独的组件，避免每次触发onChange都会导致整个组件重新渲染# 组件的onChange不要去render整个组件，可以理解为非受控组件， 状态自己控制自己， 每次改变状态传给table，或者提交的时候统一收集。不然的话 行太多，会引发性能问题 维护好项目内的公共组件 123# components/Header.tsx# 公共组件需要在注释或readme.md上说明改组件的作用和api","categories":[{"name":"Code Review","slug":"Code-Review","permalink":"https://zekiyjw.github.io/categories/Code-Review/"}],"tags":[]},{"title":"JavaScript事件委托","slug":"JavaScript事件委托","date":"2022-07-13T02:45:34.000Z","updated":"2022-07-13T02:45:34.000Z","comments":true,"path":"2022/07/13/JavaScript事件委托/","link":"","permalink":"https://zekiyjw.github.io/2022/07/13/JavaScript%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件委托 事件委托又称事件代理是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，实现处理程序对多个子孙级元素的某类型事件管理。通俗来说，就是把任意个子孙级元素的响应事件的函数委托到另一个元素（通常为委托元素的祖先元素） HTML 123456789&lt;body&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;4&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 普通写法 12345678910const list = document.querySelector(&#x27;.list&#x27;);const items = list.getElementsByClassName(&#x27;item&#x27;);for(let li of items)&#123; li.addEventListener(&#x27;click&#x27;, function()&#123; console.log(&#x27;the content is:&#x27;, li.innerHTML); &#125;)&#125;# 假如列表的li较少，这种写法没有问题。如果列表很长，1000，10000，那这种写法就非常消耗性能，需要不断的去给元素绑定，解绑 使用事件委托，将绑定委托给祖先元素 12345678910const list = document.querySelector(&#x27;.list&#x27;);list.addEventListener(&#x27;click&#x27;, function(e)&#123; const event = e || window.event; const target = event.target || event.srcElement; if(target.nodeName.toLocaleLowerCase() === &#x27;li&#x27;)&#123; console.log(&#x27;the content is:&#x27;, target.innerHTML); &#125;&#125;) 假如点击的是li标签中的子元素，那么上述的判断就有问题。详见JavaScript 事件委托详解 事件绑定解决方案 绑定事件越多，浏览器内存占用越大，严重影响性能 局部刷新的盛行，导致每次加载完，都要重新绑定事件 部分浏览器移除元素时，绑定的事件并没有被及时移除，导致的内存泄露，严重影响性能 大部分局部刷新，只是显示的数据，而操作却是大部分相同的，重复绑定，会导致到码的耦合性过大，严重影响后期的维护 优点 减少内存消耗。DOM树层级较深，绑定事件越多，浏览器内存占用越大，严重影响性能。 缺点 onfoucus、onblur之类的事件本身没有事件冒泡机制，无法使用事件委托 mouseover、mousemove这样的鼠标、滚轮等事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也不适合事件委托 优化手段 只在必须的地方使用事件委托，比如网络请求的局部刷新区域 尽量减少绑定的层级，不在&lt;body&gt;元素上进行绑定 减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中，由这个事件委托的回调，来进行分发","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zekiyjw.github.io/categories/JavaScript/"}],"tags":[]},{"title":"for循环实现每隔一秒打印下标","slug":"for循环实现每隔一秒打印下标","date":"2022-07-05T08:49:23.000Z","updated":"2022-07-05T08:49:23.000Z","comments":true,"path":"2022/07/05/for循环实现每隔一秒打印下标/","link":"","permalink":"https://zekiyjw.github.io/2022/07/05/for%E5%BE%AA%E7%8E%AF%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0%E4%B8%8B%E6%A0%87/","excerpt":"","text":"1234567for(var i = 0; i &lt; 6; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;, i * 1000)&#125;# 大家猜猜最后打印得结果是什么 0,1,2,3,4,5 ? 上图 为什么呢? 这里涉及到作用域 事件循环等知识点 作用域 引用《你不知道的 Javascript》中的一个比喻，可以把作用域链想象成一座高楼，第一层代表当前执行作用域，楼的顶层代表全局作用域。我们在查找变量时会先在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有就继续向上找。依次类推。到达顶层后（全局作用域），可能找到了你所需要的变量，也可能没找到，但无论如何查找过程都将停止。 事件循环 JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。 如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。 （3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 只要主线程空了，就会去读取&quot;任务队列&quot;，这就是 JavaScript 的运行机制。这个过程会不断重复。 在了解这两个知识点后，让我们回到题目中 首先是一个 for 循环，var 声明一个变量 i; var 申明的变量是全局变量 记住这一点 然后来到 for 循环内容，是一个延时器，setTimeout 实际就是一个异步任务，它会被放在任务队列，在等待主线程执行完后才会执行它 有的同学就很聪明说，那我把 setTimeout 的延时设置为 0，立即执行就可以了吗? 不行! 上代码 123456for(var i = 0; i &lt; 6; i++)&#123; console.log(i); setTimeout(function()&#123; console.log(i); &#125;, 0)&#125; 看到了吗？是先执行的for循环，然后再执行的setTimeout。因为setTimeout实际上是在任务队列的尾部添加了一个事件。因此要等到同步任务和任务队列现有的事件都执行完，才会得到执行。 并且i是由var全局声明的，等到延时器执行时，它已经是6了。 知道是什么问题造成的，那就好解决了 一、改 var 为 let 12345for(let i = 0; i &lt; 6; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;, i * 1000)&#125; for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量 二、立即执行表达式函数(IIFE) 1234567for(var i = 0; i &lt; 6; i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); &#125;, i * 1000) &#125;)(i)&#125; 三、引入bind函数 12345for(var i = 0; i &lt; 6; i++)&#123; setTimeout(function(i)&#123; console.log(i); &#125;.bind(null, i), i * 1000)&#125; 四、利用setTimeout第三个参数 12345for(var i = 0; i &lt; 6; i++)&#123; setTimeout(function(i)&#123; console.log(i); &#125;, i * 1000, i)&#125; 本文借鉴于彻底理解setTimeout()","categories":[{"name":"面试","slug":"面试","permalink":"https://zekiyjw.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://zekiyjw.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"JavaScript如何判断移动设备","slug":"JavaScript判断设备是否为手机端","date":"2022-07-04T03:24:05.000Z","updated":"2022-07-04T03:24:05.000Z","comments":true,"path":"2022/07/04/JavaScript判断设备是否为手机端/","link":"","permalink":"https://zekiyjw.github.io/2022/07/04/JavaScript%E5%88%A4%E6%96%AD%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E4%B8%BA%E6%89%8B%E6%9C%BA%E7%AB%AF/","excerpt":"","text":"本文给大家提供五种解决方案 一、window.navigator window.navigator.userAgent：汉译用户代理。它首部包含了一个特征字符，可以让网络协议的端来识别发送请求的代理软件的应用程序类型、操作部、用户软件以及版本号 1userAgent: &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1&quot; 我们通过window.navigator.userAgent属性拿到这个字符串，只要里面包含Android、iPhone、iPad、iPod、Symbian等关键字，就可以认定是移动设备 Tips:什么是 Symbian? 上代码 12345678910111213141516const isMobile = () =&gt; &#123; let u = window.navigator.userAgent; if ( u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;iPhone&#x27;) &gt; -1 || u.indexOf(&#x27;iPad&#x27;) &gt; -1 || u.indexOf(&#x27;iPod&#x27;) &gt; -1 || u.indexOf(&#x27;Symbian&#x27;) &gt; -1 ) &#123; return true; &#125; else &#123; return false; &#125;&#125;;# But! userAgent 是可以被修改的 具体操作请看这篇文章Chrome 浏览器如何修改 User-Agent window.navigator.userAgentData：将 user agent 字符串解析为一个对象，该对象的mobile属性，返回一个布尔值，表示用户是否使用移动设备 12# 苹果的 Safari 浏览器和 Firefox 浏览器都不支持这个属性const isMobile = navigator.userAgentData.mobile; 具体情况可以查看 Caniuse 网站。 navigator.platform：它返回一个字符串，表示用户的操作系统 123if (/Android|iPhone|iPad|iPod/i.test(navigator.platform)) &#123; # 当前设备是移动设备&#125; 二、侦听屏幕宽度以及设备指针 window.screen对象返回用户设备的屏幕信息，该对象的 width 属性是屏幕宽度（单位为像素）。 1234# 对手机横屏失效if (window.screen.width &lt; 500) &#123; # 当前设备是移动设备&#125; window.matchMedia()方法接收一个 CSS 的 media query 语句作为参数，判断这个语句是否生效 12# 不严谨，针对手机模拟器侦听为truelet isMobile = window.matchMedia(&quot;only screen and (max-width: 760px)&quot;).matches; 如果屏幕宽度window.screen.width小于 500 像素，就认为是手机。如果手机横屏使用就识别不了~~ 三、侦测屏幕方向 window.orientation (iPhone 的 Safari 浏览器不支持该属性) 手机屏幕可以随时更改方向，桌面设备做不到。 `window.orientation`属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回`undefined`。 上代码 123if (typeof window.orientation !== &#x27;undefined&#x27;) &#123; # 当前设备是移动设备&#125; 四、touch 事件 (推荐) 手机浏览器的 DOM 元素可以通过ontouchstart属性，为touch事件指定监听函数。桌面设备没有这个属性 上代码 12345678910111213# 第一种function isMobile()&#123; return (&quot;ontouchstart&quot; in document.documentElement);&#125;# 第二种function isMobile()&#123; try&#123; document.createEvent(&quot;TouchEvent&quot;); return true; &#125;catch(e)&#123; return false; &#125;&#125; 五、工具包 直接引用别人写好的工具包，这里推荐react-device-detect，它支持多种粒度的设备侦测 上代码 12345import &#123;isMobile&#125; from &#x27;react-device-detect&#x27;;if (isMobile) &#123; # 当前设备是移动设备&#125; 本文借鉴于阮一峰老师的JavaScript 侦测手机浏览器的五种方法","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zekiyjw.github.io/categories/JavaScript/"}],"tags":[{"name":"自定义工具函数","slug":"自定义工具函数","permalink":"https://zekiyjw.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"}]},{"title":"React Class类名冲突、重复样式怎么办?","slug":"React Class类名冲突、重复样式怎么办","date":"2022-06-29T09:29:27.000Z","updated":"2022-07-01T09:29:27.000Z","comments":true,"path":"2022/06/29/React Class类名冲突、重复样式怎么办/","link":"","permalink":"https://zekiyjw.github.io/2022/06/29/React%20Class%E7%B1%BB%E5%90%8D%E5%86%B2%E7%AA%81%E3%80%81%E9%87%8D%E5%A4%8D%E6%A0%B7%E5%BC%8F%E6%80%8E%E4%B9%88%E5%8A%9E/","excerpt":"","text":"本文给大家提供两种解决方案 CSS in Js 它是一种模式，主要借助第三方库生成随机类名称来建立一种局部类名的方式。 第一步安装 styled-components 库 1npm install -S styed-components 第二步 引入 styled-components，并在Js中写Css代码 1234567891011121314151617181920212223242526272829import styled from &quot;styled-components&quot;;// 声明一个公共样式const style_div = &#123; width: 100, height: 100, color: &quot;#fff&quot;, textAlign: &quot;center&quot;, lineHeight: &quot;100px&quot;&#125;;// 声明一个带背景色的DivAconst DivA = styled.div` background-color: red;`;// 声明一个带背景色的DivBconst DivB = styled.div` background-color: green;`;export default function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;DivA style=&#123;style_div&#125;&gt;DivA&lt;/DivA&gt; &lt;DivB style=&#123;style_div&#125;&gt;DivB&lt;/DivB&gt; &lt;/div&gt; );&#125; CSS in Js效果图 Tips:要避免在render方法中声明样式化组件，这样程序虽然不会报错，但是会引起性能问题，引起组件不必要的渲染！ CSS Module 在使用create-react-app脚手架创建的项目后，该项目是支持css-module的 样式文件的名称必须以xxx.module.css或者xxx.module.scss的形式命名；例如styles.module.css 第一步新建styles.module.css文件 1234567.pink_box &#123; background-color: pink;&#125;.skyblue_box&#123; background-color: skyblue;&#125; 第二步引入styles.module.css,className以变量引入的方式进行添加,例如:className ={styles.counter} 12345678910import styles from &quot;./styles.module.css&quot;;export default function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&#123;styles.pink_box&#125;&gt;DivA&lt;/div&gt; &lt;div className=&#123;styles.skyblue_box&#125;&gt;DivB&lt;/div&gt; &lt;/div&gt; );&#125; CSS Module效果图 CSS工程化 随着项目越来越大，人越来越多，命名慢慢成为问题，类名重复，样式污染。CSS社区也诞生了相应的模块化解决方案 CSS命名方法论：通过人工的方式来约定命名规则 CSS Module: 一个css文件就是一个独立的模块 CSS in Js: 在Js中写Css 总结：个人推荐CSS Module，因为功能简单，只加入了局部作用域和模块依赖，可以保证某个组件的样式，不会影响其他组件","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zekiyjw.github.io/categories/CSS/"}],"tags":[]}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zekiyjw.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://zekiyjw.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Code Review","slug":"Code-Review","permalink":"https://zekiyjw.github.io/categories/Code-Review/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zekiyjw.github.io/categories/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://zekiyjw.github.io/categories/CSS/"}],"tags":[{"name":"你不知道的JavaScript-上卷","slug":"你不知道的JavaScript-上卷","permalink":"https://zekiyjw.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7/"},{"name":"编程题","slug":"编程题","permalink":"https://zekiyjw.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"自定义工具函数","slug":"自定义工具函数","permalink":"https://zekiyjw.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"}]}